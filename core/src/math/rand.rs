use core::fmt::Debug;
use core::ops::Range;
use std::array::from_fn;

use crate::math::{Vec2, Vec3};

/// Trait for generating values sampled from a probability distribution.
pub trait Distrib {
    /// The type of values generated by this distribution.
    type Output;
    /// Returns the next pseudo-random value sampled from this distribution.
    fn next(&mut self) -> Self::Output;
}

/// A pseudo-random number generator (PRNG) that uses the XorShift algorithm
/// to generate 64 bits of randomness at a time, represented by a `u64`.
#[derive(Copy, Clone, Debug)]
#[repr(transparent)]
pub struct XorShift64(u64);

impl XorShift64 {
    /// Returns a new `XorShift64` seeded by the given number.
    pub fn from_seed(seed: u64) -> Self {
        assert_ne!(seed, 0, "xorshift seed cannot be zero");
        Self(seed)
    }

    /// Returns a new `XorShift64` seeded by the current system time.
    #[cfg(feature = "std")]
    pub fn from_time() -> Self {
        let t = std::time::SystemTime::UNIX_EPOCH
            .elapsed()
            .unwrap();
        Self(t.as_micros() as u64)
    }

    /// Returns 64 bits of pseudo-randomness.
    pub fn gen(&mut self) -> u64 {
        let Self(x) = self;
        *x ^= *x << 13;
        *x ^= *x >> 7;
        *x ^= *x << 17;
        *x
    }
}

impl Default for XorShift64 {
    fn default() -> Self {
        Self::from_seed(1)
    }
}

/// A uniform distribution of values in the given range.
#[derive(Clone, Debug)]
pub struct Uniform<T>(pub XorShift64, pub Range<T>);

/// A uniform distribution of 2-vectors on the (perimeter of) the unit circle.
///
/// That is, vectors with length equal to 1.0.
#[derive(Copy, Clone, Debug)]
pub struct UnitCircle(pub XorShift64);

/// A uniform distribution of 2-vectors in the (closed) unit disk.
///
/// That is, vectors with length less than or equal to 1.0.
#[derive(Copy, Clone, Debug, Default)]
pub struct UnitDisk(pub XorShift64);

/// A uniform distribution of 3-vectors on the (surface of) the unit sphere.
///
/// That is, vectors with length equal to 1.0.
#[derive(Copy, Clone, Debug, Default)]
pub struct UnitSphere(pub XorShift64);

/// A uniform distribution of 3-vectors within the (closed) unit ball.
///
/// That is, vectors with length less than or equal to 1.0.
#[derive(Copy, Clone, Debug, Default)]
pub struct UnitBall(pub XorShift64);

/// A Bernoulli distribution.
///
/// Generates boolean values such that:
/// * P(true) = p
/// * P(false) = 1 - p.
///
///  given a parameter p âˆˆ [0.0, 1.0].
#[derive(Copy, Clone, Debug)]
pub struct Bernoulli(pub XorShift64, pub f32);

impl Distrib for Uniform<i32> {
    type Output = i32;

    /// Returns a uniformly distributed `i32` in the given range.
    fn next(&mut self) -> i32 {
        let Self(gen, Range { start, end }) = self;
        let bits = gen.gen() as i32;
        bits.rem_euclid(*end - *start) + *start
    }
}

impl Distrib for Uniform<f32> {
    type Output = f32;

    /// Returns a uniformly distributed `f32` in the given range.
    fn next(&mut self) -> f32 {
        let Self(gen, Range { start, end }) = self;
        // Bit repr of a random f32 in range 1.0..2.0
        let bits = 127 << 23 | gen.gen() >> 41;
        let unit = f32::from_bits(bits as u32) - 1.0;
        unit * (*end - *start) + *start
    }
}

impl<T, O, const N: usize> Distrib for Uniform<[T; N]>
where
    T: Copy,
    Uniform<T>: Distrib<Output = O>,
{
    type Output = [O; N];

    /// Returns an array of values representing a uniformly distributed point
    /// within the N-dimensional rectangular volume bounded by the given range.
    fn next(&mut self) -> [O; N] {
        from_fn(|i| {
            let Self(gen, rg) = self;
            let mut d = Uniform(*gen, rg.start[i]..rg.end[i]);
            let r = d.next();
            self.0 = d.0;
            r
        })
    }
}

impl Distrib for UnitCircle {
    type Output = Vec2;

    /// Returns a vector uniformly distributed on the unit circle.
    fn next(&mut self) -> Vec2 {
        let mut d = Uniform(self.0, [-1.0; 2]..[1.0; 2]);
        let res = Vec2::from(d.next()).normalize();
        self.0 = d.0;
        res
    }
}

impl Distrib for UnitDisk {
    type Output = Vec2;

    /// Returns a vector uniformly distributed within the unit disk.
    fn next(&mut self) -> Vec2 {
        let mut d = Uniform(self.0, [-1.0f32; 2]..[1.0; 2]);
        loop {
            let v = Vec2::from(d.next());
            if v.dot(&v) <= 1.0 {
                self.0 = d.0;
                return v;
            }
        }
    }
}

impl Distrib for UnitSphere {
    type Output = Vec3;

    /// Returns a vector uniformly distributed on the unit sphere.
    fn next(&mut self) -> Vec3 {
        let mut d = Uniform(self.0, [-1.0f32; 3]..[1.0; 3]);
        let res = Vec3::from(d.next()).normalize();
        self.0 = d.0;
        res
    }
}

impl Distrib for UnitBall {
    type Output = Vec3;

    /// Returns a vector uniformly distributed within the unit ball.
    fn next(&mut self) -> Vec3 {
        let mut d = Uniform(self.0, [-1.0; 3]..[1.0; 3]);
        loop {
            let v = Vec3::from(d.next());
            if v.dot(&v) <= 1.0 {
                self.0 = d.0;
                return v;
            }
        }
    }
}

impl Distrib for Bernoulli {
    type Output = bool;

    /// Returns boolean values sampled from a Bernoulli distribution.
    fn next(&mut self) -> bool {
        let mut d = Uniform(self.0, 0.0f32..1.0);
        let res = d.next() < self.1;
        self.0 = d.0;
        res
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const COUNT: i32 = 1000;

    #[test]
    fn uniform_i32() {
        let gen = XorShift64::default();
        let mut d = Uniform(gen, -123..456);

        for _ in 0..COUNT {
            let r = d.next();
            assert!(-123 <= r && r < 456);
        }
    }

    #[test]
    fn uniform_i32_array() {
        let gen = XorShift64::default();
        let mut d = Uniform(gen, [0, -10]..[10, 15]);

        for _ in 0..COUNT {
            let [x, y] = d.next();
            assert!(0 <= x && x < 10);
            assert!(-10 <= y && x < 15);
        }
    }

    #[test]
    fn uniform_f32() {
        let gen = XorShift64::default();
        let mut d = Uniform(gen, -1.23..4.56);

        for _ in 0..COUNT {
            let r = d.next();
            assert!(-1.23 <= r && r < 4.56);
        }
    }

    #[test]
    fn bernoulli() {
        let gen = XorShift64::default();
        let mut d = Bernoulli(gen, 0.1);

        let mut trues = 0;
        for _ in 0..COUNT {
            trues += d.next() as u32;
        }
        assert_eq!(trues, 93);
    }
}
