//! Various solids of revolution.

use alloc::vec::Vec;
use core::ops::Range;

use retrofire_core::geom::{
    Mesh, Normal2, Normal3, Polyline, Tri, Vertex, Vertex2, Vertex3, tri,
    vertex,
};
use retrofire_core::math::{
    Angle, Lerp, Parametric, Point3, Vary, Vec3, polar, pt2, pt3, rotate2,
    turns, vec2, vec3,
};
use retrofire_core::render::{TexCoord, uv};

use super::Build;

/// A surface of revolution generated by rotating a 2D curve around the y-axis.
#[derive(Clone, Debug, Default)]
pub struct Lathe<P> {
    /// The curve defining the shape.
    pub points: P,
    /// The number of facets used to approximate the surface.
    pub sectors: u32,
    /// The number of vertical segments used to approximate the surface.
    pub segments: u32,
    /// Whether to add flat caps to both ends of the object.
    pub capped: bool,
    /// The range of angles over which to rotate.
    pub az_range: Range<Angle>,
}

/// TODO
pub struct Sphere {
    pub sectors: u32,
    pub segments: u32,
    pub radius: f32,
}

/// Toroidal polyhedron.
pub struct Torus {
    /// Distance from the origin to the center of the tube.
    pub major_radius: f32,
    /// Radius of the cross-section of the tube.
    pub minor_radius: f32,

    pub major_sectors: u32,
    pub minor_sectors: u32,
}

/// Right cylinder with regular *n*-gonal cross-section.
pub struct Cylinder {
    pub sectors: u32,
    pub segments: u32,
    pub capped: bool,
    pub radius: f32,
}

/// TODO
pub struct Cone {
    pub sectors: u32,
    pub segments: u32,
    pub capped: bool,
    pub base_radius: f32,
    pub apex_radius: f32,
}

/// Cylinder with hemispherical caps.
pub struct Capsule {
    pub sectors: u32,
    pub body_segments: u32,
    pub cap_segments: u32,
    pub radius: f32,
}

//
// Inherent impls
//

impl<P: Parametric<Vertex2<Normal2, ()>>> Lathe<P> {
    pub fn new(points: P, sectors: u32, segments: u32) -> Self {
        assert!(sectors >= 3, "sectors must be at least 3, was {sectors}");
        Self {
            points,
            sectors,
            segments,
            capped: false,
            az_range: turns(0.0)..turns(1.0),
        }
    }

    pub fn capped(self, capped: bool) -> Self {
        Self { capped, ..self }
    }

    /// Builds the lathe mesh.
    #[inline(never)]
    pub fn build_with<A>(
        self,
        f: &mut dyn FnMut(Point3, Normal3, TexCoord) -> Vertex3<A>,
    ) -> Mesh<A> {
        let secs = self.sectors as usize;
        let segs = self.segments as usize;
        let caps = 2 * self.capped as usize;

        // Fencepost problem: n + 1 vertices for n segments
        let verts_per_sec = segs + 1;

        // Precompute capacity
        let n_faces = segs * secs * 2 + (secs - 2) * caps;
        let n_verts = verts_per_sec * (secs + 1) + secs * caps;
        let mut m = Mesh {
            faces: Vec::with_capacity(n_faces),
            verts: Vec::with_capacity(n_verts),
        };

        create_faces(secs, verts_per_sec, &mut m.faces);
        create_verts(
            f,
            &self.points,
            secs,
            verts_per_sec,
            self.az_range,
            &mut m.verts,
        );

        // Create optional caps
        if self.capped && verts_per_sec > 0 {
            let l = m.verts.len();
            // Duplicate the bottom ring of vertices to make the bottom cap...
            make_cap(&mut m, f, 0..secs, -Vec3::Y);
            // ...and the top vertices to make the top cap
            make_cap(&mut m, f, l - secs..l, Vec3::Y);
        }
        m
    }
}

#[inline(never)]
fn create_faces(secs: usize, verts_per_sec: usize, out: &mut Vec<Tri<usize>>) {
    for j in 1..verts_per_sec {
        let n = secs + 1;
        for i in 1..n {
            let p = (j - 1) * n + i - 1;
            let q = (j - 1) * n + i;
            let r = j * n + i - 1;
            let s = j * n + i;
            // TODO could alternate direction of diagonal
            //    - or support quads
            // r _____ s       _____
            //   |/|/|    ->   |\|/|
            // p |/|/| q       |/|\|
            out.push(tri(p, q, s));
            out.push(tri(p, s, r));
        }
    }
}

#[inline(never)]
fn create_verts<A>(
    f: &mut dyn FnMut(Point3, Normal3, TexCoord) -> Vertex3<A>,
    pts: &impl Parametric<Vertex2<Normal2, ()>>,
    secs: usize,
    verts_per_sec: usize,
    az_range: Range<Angle>,
    out: &mut Vec<Vertex3<A>>,
) {
    let Range { start, end } = az_range;
    let rot = rotate2((end - start) / secs as f32);
    let start = rotate2(start);

    // Create vertices
    for (v, Vertex { pos, attrib: n }) in 0.0
        .vary_to(1.0, verts_per_sec as u32)
        .map(|t| (t, pts.eval(t)))
    {
        let mut pos_xz = start.apply(&pt2(pos.x(), 0.0));
        let mut n_xz = start.apply(&vec2(n.x(), 0.0));

        for u in 0..=secs {
            let pos = pt3(pos_xz.x(), pos.y(), pos_xz.y());
            let norm = vec3(n_xz.x(), n.y(), n_xz.y());
            let v = f(pos, norm, uv(u as f32 / secs as f32, v));
            out.push(v);

            pos_xz = rot.apply(&pos_xz);
            n_xz = rot.apply(&n_xz);
        }
    }
}

#[inline(never)]
fn make_cap<A>(
    m: &mut Mesh<A>,
    f: &mut dyn FnMut(Point3, Normal3, TexCoord) -> Vertex3<A>,
    rg: Range<usize>,
    n: Normal3,
) {
    let verts = &mut m.verts;
    let secs = rg.len();
    let l = verts.len();

    verts.reserve(secs);
    for i in rg {
        let p = verts[i].pos.to();
        let uv = uv(0.0, 0.0); // TODO
        verts.push(f(p, n, uv));
    }

    // Adjust winding depending on whether top or bottom
    let (j, k) = if n.y() < 0.0 { (1, 0) } else { (0, 1) };
    for i in 1..secs - 1 {
        m.faces.push(tri(l, l + i + j, l + i + k));
    }
}

//
// Local trait impls
//

impl<P: Parametric<Vertex2<Normal2, ()>>> Build<Normal3> for Lathe<P> {
    fn build(self) -> Mesh<Normal3> {
        self.build_with(&mut |p, n, _| vertex(p.to(), n))
    }
}
impl<P: Parametric<Vertex2<Normal2, ()>>> Build<TexCoord> for Lathe<P> {
    fn build(self) -> Mesh<TexCoord> {
        self.build_with(&mut |p, _, tc| vertex(p.to(), tc))
    }
}
impl<P: Parametric<Vertex2<Normal2, ()>>> Build<(Normal3, TexCoord)>
    for Lathe<P>
{
    fn build(self) -> Mesh<(Normal3, TexCoord)> {
        self.build_with(&mut |p, n, tc| vertex(p.to(), (n, tc)))
    }
}

impl Sphere {
    fn lathe(self) -> Lathe<impl Parametric<Vertex2<Normal2, ()>>> {
        let Self { sectors, segments, radius } = self;
        let pts = move |t| {
            let a = (-0.25).lerp(&0.25, t);
            let n = polar(1.0, turns(a)).to_cart();
            vertex((n * radius).to_pt(), n)
        };
        Lathe::new(pts, sectors, segments)
    }
}

impl Build<Normal3> for Sphere {
    /// Builds a spherical mesh with normals.
    fn build(self) -> Mesh<Normal3> {
        self.lathe().build()
    }
}
impl Build<TexCoord> for Sphere {
    /// Builds a spherical mesh with texture coordinates.
    fn build(self) -> Mesh<TexCoord> {
        self.lathe().build()
    }
}

impl Torus {
    fn lathe(self) -> Lathe<impl Parametric<Vertex2<Normal2, ()>>> {
        let pts = move |t| {
            let a = 0.0.lerp(&1.0, t);
            let v = polar(self.minor_radius, turns(a)).to_cart();
            vertex(pt2(self.major_radius, 0.0) + v.to(), v.normalize())
        };
        Lathe::new(pts, self.major_sectors, self.minor_sectors)
    }
}
impl Build<Normal3> for Torus {
    /// Builds the toroidal mesh.
    fn build(self) -> Mesh<Normal3> {
        self.lathe().build()
    }
}
impl Build<TexCoord> for Torus {
    /// Builds the toroidal mesh.
    fn build(self) -> Mesh<TexCoord> {
        self.lathe().build()
    }
}

impl Build<Normal3> for Cylinder {
    /// Builds the cylindrical mesh.
    fn build(self) -> Mesh<Normal3> {
        #[rustfmt::skip]
        let Self { sectors, segments, capped, radius } = self;
        Cone {
            sectors,
            segments,
            capped,
            base_radius: radius,
            apex_radius: radius,
        }
        .build()
    }
}
impl Build<TexCoord> for Cylinder {
    /// Builds the cylindrical mesh.
    fn build(self) -> Mesh<TexCoord> {
        #[rustfmt::skip]
        let Self { sectors, segments, capped, radius } = self;
        Cone {
            sectors,
            segments,
            capped,
            base_radius: radius,
            apex_radius: radius,
        }
        .build()
    }
}

impl Cone {
    fn lathe(self) -> Lathe<impl Parametric<Vertex2<Normal2, ()>>> {
        assert!(self.segments > 0, "segments cannot be zero");

        let base_pt = pt2(self.base_radius, -1.0);
        let apex_pt = pt2(self.apex_radius, 1.0);
        let n = (base_pt - apex_pt).perp().normalize();

        let pts = move |t| {
            let pt = base_pt.lerp(&apex_pt, t);
            vertex(pt, n)
        };
        Lathe::new(pts, self.sectors, self.segments).capped(self.capped)
    }
}
impl Build<Normal3> for Cone {
    /// Builds the conical mesh.
    fn build(self) -> Mesh<Normal3> {
        self.lathe().build()
    }
}
impl Build<TexCoord> for Cone {
    /// Builds the conical mesh.
    fn build(self) -> Mesh<TexCoord> {
        self.lathe().build()
    }
}

impl Capsule {
    fn lathe(self) -> Lathe<impl Parametric<Vertex2<Normal2, ()>>> {
        #[rustfmt::skip]
        let Self { sectors, body_segments, cap_segments, radius } = self;
        assert!(body_segments > 0, "body segments cannot be zero");
        assert!(cap_segments > 0, "cap segments cannot be zero");

        // Must be collected to allow rev()
        let bottom_pts: Vec<_> = turns(-0.25)
            .vary_to(turns(0.0), cap_segments + 1)
            .take(cap_segments as usize)
            .map(|alt| polar(radius, alt).to_cart())
            .map(|v| vertex(pt2(0.0, -1.0) + v, v.normalize()))
            .collect();

        let top_pts = bottom_pts
            .iter()
            .map(|Vertex { pos, attrib: n }| {
                vertex(pt2(pos.x(), -pos.y()), vec2(n.x(), -n.y()))
            })
            .rev();

        let body_pts = (-1.0)
            .vary_to(1.0, body_segments + 1)
            .map(|t| vertex(pt2(radius, t), vec2(1.0, 0.0)));

        let pts: Vec<_> = bottom_pts
            .iter()
            .copied()
            .chain(body_pts)
            .chain(top_pts)
            .collect();

        let segments = 2 * cap_segments + body_segments;
        Lathe::new(Polyline::new(pts), sectors, segments)
    }
}

impl Build<Normal3> for Capsule {
    /// Builds the capsule mesh.
    fn build(self) -> Mesh<Normal3> {
        self.lathe().build()
    }
}
impl Build<TexCoord> for Capsule {
    /// Builds the capsule mesh.
    fn build(self) -> Mesh<TexCoord> {
        self.lathe().build()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    type Mesh = super::Mesh<Normal3>;

    #[test]
    fn sphere_verts_faces() {
        let sectors = 4;
        let segments = 3;
        let s: Mesh = Sphere { sectors, segments, radius: 1.0 }.build();

        assert_eq!(s.faces.len() as u32, 2 * sectors * segments);
        assert_eq!(s.faces.len(), s.faces.capacity());

        assert_eq!(s.verts.len() as u32, (sectors + 1) * (segments + 1));
        assert_eq!(s.verts.len(), s.verts.capacity());
    }

    #[test]
    fn cylinder_verts_faces_capped() {
        let sectors = 4;
        let segments = 3;
        let c: Mesh = Cylinder {
            sectors,
            segments,
            capped: true,
            radius: 1.0,
        }
        .build();

        let faces_expected = 2 * sectors * segments + 2 * (sectors - 2);
        assert_eq!(c.faces.len() as u32, faces_expected);
        assert_eq!(c.faces.len(), c.faces.capacity());

        let verts_expected = (sectors + 1) * (segments + 1) + 2 * sectors;
        assert_eq!(c.verts.len() as u32, verts_expected);
        assert_eq!(c.verts.len(), c.verts.capacity());
    }

    #[test]
    fn cylinder_verts_faces_uncapped() {
        let sectors = 4;
        let segments = 3;
        let c: Mesh = Cylinder {
            sectors,
            segments,
            capped: false,
            radius: 1.0,
        }
        .build();

        let faces_expected = 2 * sectors * segments;
        assert_eq!(c.faces.len() as u32, faces_expected);
        assert_eq!(c.faces.len(), c.faces.capacity());

        let verts_expected = (sectors + 1) * (segments + 1);
        assert_eq!(c.verts.len() as u32, verts_expected);
        assert_eq!(c.verts.len(), c.verts.capacity());
    }

    #[test]
    fn capsule_verts_faces() {
        let sectors = 4;
        let body_segments = 2;
        let cap_segments = 2;
        let c: Mesh = Capsule {
            sectors,
            body_segments,
            cap_segments,
            radius: 1.0,
        }
        .build();

        let faces_expected =
            2 * sectors * body_segments + 2 * 2 * sectors * cap_segments;
        assert_eq!(c.faces.len() as u32, faces_expected);
        assert_eq!(c.faces.len(), c.faces.capacity());

        let verts_expected = (sectors + 1) * (body_segments + 1)
            + 2 * (sectors + 1) * (cap_segments);
        assert_eq!(c.verts.len() as u32, verts_expected);
        assert_eq!(c.verts.len(), c.verts.capacity());
    }

    #[test]
    fn torus_verts_faces_capped() {
        let major_sectors = 6;
        let minor_sectors = 4;
        let t: Mesh = Torus {
            major_radius: 1.0,
            minor_radius: 0.2,
            major_sectors,
            minor_sectors,
        }
        .build();

        let faces_expected = 2 * major_sectors * minor_sectors;
        assert_eq!(t.faces.len() as u32, faces_expected);
        assert_eq!(t.faces.len(), t.faces.capacity());

        let verts_expected = (major_sectors + 1) * (minor_sectors + 1);
        assert_eq!(t.verts.len() as u32, verts_expected);
        assert_eq!(t.verts.len(), t.verts.capacity());
    }
}
