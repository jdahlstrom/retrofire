//! Mesh approximations of various geometric shapes.

use core::array::from_fn;

use re::geom::mesh::Mesh;
use re::geom::{vertex, Tri};
use re::math::vary::RangeExt;
use re::math::vec::splat;
use re::math::{degs, polar, turns, vec2, vec3, Vary, Vec2, Vec3};
use re::render::tex::{uv, TexCoord};

/// A surface normal.
// TODO Use distinct type rather than alias
pub type Normal3 = Vec3;

/// A rectangular cuboid, defined by two opposite vertices.
#[derive(Copy, Clone, Debug)]
pub struct Box {
    /// The left bottom near corner of the box.
    pub left_bot_near: Vec3,
    /// The right top far corner of the box.
    pub right_top_far: Vec3,
}

/// A regular octahedron: a polyhedron with eight triangular faces.
///
/// Has vertices at (±1, 0, 0), (0, ±1, 0), and (0, 0, ±1).
#[derive(Copy, Clone, Debug, Default)]
pub struct Octahedron;

/// A regular octahedron: a polyhedron with 12 pentagonal faces.
#[derive(Copy, Clone, Debug, Default)]
pub struct Dodecahedron;

/// A regular octahedron: a polyhedron with 20 triangular faces.
#[derive(Copy, Clone, Debug, Default)]
pub struct Icosahedron;

/// A surface-of-revolution shape generated by rotating a polyline
/// lying on the xy plane one full revolution around the y axis.
#[derive(Clone, Debug, Default)]
pub struct Lathe {
    /// The polyline defining the shape.
    pub pts: Vec<Vec2>,
    /// The number of facets used to approximate the surface of revolution.
    pub sectors: u32,
    /// Whether to add flat caps to both ends of the object. Has no effect
    /// if the endpoints already lie on the y axis.
    pub capped: bool,
}

#[derive(Copy, Clone, Debug)]
pub struct Sphere {
    pub sectors: u32,
    pub segments: u32,
    pub radius: f32,
}

/// A toroidal polyhedron.
#[derive(Copy, Clone, Debug)]
pub struct Torus {
    /// Distance from the origin to the center of the tube.
    pub major_radius: f32,
    /// Radius of the cross-section of the tube.
    pub minor_radius: f32,

    pub major_sectors: u32,
    pub minor_sectors: u32,
}

/// A right cylinder with regular *n*-gonal cross-section.
#[derive(Copy, Clone, Debug)]
pub struct Cylinder {
    pub sectors: u32,
    pub capped: bool,
    pub radius: f32,
}

#[derive(Copy, Clone, Debug)]
pub struct Cone {
    pub sectors: u32,
    pub capped: bool,
    pub base_radius: f32,
    pub apex_radius: f32,
}

/// A cylinder with hemispherical caps.
#[derive(Copy, Clone, Debug)]
pub struct Capsule {
    pub sectors: u32,
    pub cap_segments: u32,
    pub radius: f32,
}

impl Default for Box {
    /// Creates a cube with unit-length edges, centered at the origin.
    fn default() -> Self {
        Self {
            left_bot_near: splat(-0.5),
            right_top_far: splat(0.5),
        }
    }
}

impl Box {
    const COORDS: [Vec3; 8] = [
        vec3(0.0, 0.0, 0.0), // 0b000
        vec3(0.0, 0.0, 1.0), // 0b001
        vec3(0.0, 1.0, 0.0), // 0b010
        vec3(0.0, 1.0, 1.0), // 0b011
        vec3(1.0, 0.0, 0.0), // 0b100
        vec3(1.0, 0.0, 1.0), // 0b101
        vec3(1.0, 1.0, 0.0), // 0b110
        vec3(1.0, 1.0, 1.0), // 0b111
    ];
    const NORMS: [Normal3; 6] = [
        vec3(-1.0, 0.0, 0.0),
        vec3(1.0, 0.0, 0.0),
        vec3(0.0, -1.0, 0.0),
        vec3(0.0, 1.0, 0.0),
        vec3(0.0, 0.0, -1.0),
        vec3(0.0, 0.0, 1.0),
    ];
    #[allow(unused)]
    const TEX_COORDS: [TexCoord; 4] =
        [uv(0.0, 0.0), uv(1.0, 0.0), uv(0.0, 1.0), uv(1.0, 1.0)];
    #[rustfmt::skip]
    const VERTS: [(usize, [usize; 2]); 24] = [
        // left
        (0b011, [0, 0]), (0b010, [0, 1]), (0b001, [0, 2]), (0b000, [0, 3]),
        // right
        (0b110, [1, 0]), (0b111, [1, 1]), (0b100, [1, 2]), (0b101, [1, 3]),
        // bottom
        (0b000, [2, 0]), (0b100, [2, 1]), (0b001, [2, 2]), (0b101, [2, 3]),
        // top
        (0b011, [3, 0]), (0b111, [3, 1]), (0b010, [3, 2]), (0b110, [3, 3]),
        // front
        (0b010, [4, 0]), (0b110, [4, 1]), (0b000, [4, 2]), (0b100, [4, 3]),
        // back
        (0b111, [5, 0]), (0b011, [5, 1]), (0b101, [5, 2]), (0b001, [5, 3]),
    ];
    #[rustfmt::skip]
    const FACES: [[usize; 3]; 12] = [
        // left
        [0, 1, 3], [0, 3, 2],
        // right
        [4, 5, 7], [4, 7, 6],
        // bottom
        [8, 9, 11], [8, 11, 10],
        // top
        [12, 13, 15], [12, 15, 14],
        // front
        [16, 17, 19], [16, 19, 18],
        // back
        [20, 21, 23], [20, 23, 22],
    ];

    pub fn build(self) -> Mesh<Normal3> {
        let verts = Self::VERTS
            .iter()
            .map(|&(pos_idx, [norm_idx, _uv_idx])| {
                (Self::COORDS[pos_idx], Self::NORMS[norm_idx])
            })
            .map(|(pos, norm)| {
                let pos = from_fn(|i| {
                    self.left_bot_near[i].lerp(&self.right_top_far[i], pos[i])
                });
                vertex(pos.into(), norm)
            })
            .collect();

        Mesh::new(Self::FACES.map(Tri).to_vec(), verts)
    }
}

impl Octahedron {
    const COORDS: [Vec3; 6] = [
        vec3(-1.0, 0.0, 0.0),
        vec3(0.0, -1.0, 0.0),
        vec3(0.0, 0.0, -1.0),
        vec3(0.0, 1.0, 0.0),
        vec3(0.0, 0.0, 1.0),
        vec3(1.0, 0.0, 0.0),
    ];
    const NORMS: [Normal3; 8] = [
        vec3(-1.0, -1.0, -1.0),
        vec3(-1.0, 1.0, -1.0),
        vec3(-1.0, 1.0, 1.0),
        vec3(-1.0, -1.0, 1.0),
        vec3(1.0, -1.0, -1.0),
        vec3(1.0, 1.0, -1.0),
        vec3(1.0, 1.0, 1.0),
        vec3(1.0, -1.0, 1.0),
    ];
    #[rustfmt::skip]
    const VERTS: [(usize, usize); 24] = [
        (0, 0), (2, 0), (1, 0),
        (0, 1), (3, 1), (2, 1),
        (0, 2), (4, 2), (3, 2),
        (0, 3), (1, 3), (4, 3),
        (1, 4), (2, 4), (5, 4),
        (2, 5), (3, 5), (5, 5),
        (3, 6), (4, 6), (5, 6),
        (1, 7), (5, 7), (4, 7),
    ];
    const FACES: [[usize; 3]; 8] = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [9, 10, 11],
        [12, 13, 14],
        [15, 16, 17],
        [18, 19, 20],
        [21, 22, 23],
    ];

    pub fn build(self) -> Mesh<Normal3> {
        Mesh::new(
            Self::FACES.map(Tri).to_vec(),
            Self::VERTS
                .iter()
                .map(|&(pos_i, norm_i)| {
                    vertex(Self::COORDS[pos_i].to(), Self::NORMS[norm_i])
                })
                .collect(),
        )
    }
}

const PHI: f32 = 1.61803401_f32;

impl Dodecahedron {
    #[rustfmt::skip]
    const COORDS: [Vec3; 20] = [
        vec3(-1.0, -1.0, -1.0),
        vec3(-1.0, -1.0,  1.0),
        vec3(-1.0,  1.0, -1.0),
        vec3(-1.0,  1.0,  1.0), // 3
        vec3( 1.0, -1.0, -1.0),
        vec3( 1.0, -1.0,  1.0), // 5
        vec3( 1.0,  1.0, -1.0), // 6
        vec3( 1.0,  1.0,  1.0),
        //
        vec3(0.0, -PHI, -1.0/PHI),
        vec3(0.0, -PHI,  1.0/PHI),
        vec3(0.0,  PHI, -1.0/PHI),
        vec3(0.0,  PHI,  1.0/PHI),
        //
        vec3(-1.0/PHI, 0.0, -PHI),
        vec3( 1.0/PHI, 0.0, -PHI),
        vec3(-1.0/PHI, 0.0,  PHI),
        vec3( 1.0/PHI, 0.0,  PHI),
        //
        vec3(-PHI, -1.0/PHI, 0.0),
        vec3(-PHI,  1.0/PHI, 0.0),
        vec3( PHI, -1.0/PHI, 0.0),
        vec3( PHI,  1.0/PHI, 0.0),
    ];
    const FACES: [[usize; 5]; 12] = [
        [0, 1],
        [0, 2],
        [0, 4],
        [3, 1],
        [3, 2],
        [3, 7],
        [5, 7],
        [5, 1],
        [5, 4],
        [6, 7],
        [6, 4],
        [6, 2],
    ];

    pub fn build(self) -> Mesh<Normal3> {
        todo!()
    }
}

impl Icosahedron {
    #[rustfmt::skip]
    const COORDS: [Vec3; 12] = [
        // -X
        vec3(-PHI, 0.0, -1.0), vec3(-PHI, 0.0, 1.0),
        // +X
        vec3( PHI, 0.0, -1.0), vec3( PHI, 0.0, 1.0),
        // -Y
        vec3(-1.0, -PHI, 0.0), vec3(1.0, -PHI, 0.0),
        // +Y
        vec3(-1.0,  PHI, 0.0), vec3(1.0,  PHI, 0.0),
        // -Z
        vec3(0.0, -1.0, -PHI), vec3(0.0, 1.0, -PHI),
        // +Z
        vec3(0.0, -1.0,  PHI), vec3(0.0, 1.0,  PHI),
    ];
    #[rustfmt::skip]
    const FACES: [[usize; 3]; 20] = [
        // -X
        [0, 1, 4], [0, 1, 6],
        // +X
        [2, 3, 5], [2, 3, 7],
        // -Y
        [4, 5, 8], [4, 5, 10],
        // +Y
        [6, 7, 9], [6, 7, 11],
        // -Z
        [8, 9, 0], [8, 9, 2],
        // +Z
        [10, 11, 1], [10, 11, 3],
        // The "corners"
        [0, 4,  8], [0, 6,  9],
        [1, 4, 10], [1, 6, 11],
        [2, 5,  8], [2, 7,  9],
        [3, 5, 10], [3, 7, 11],
    ];

    pub fn build(self) -> Mesh<Normal3> {
        // TODO normals
        Mesh::new(
            Self::FACES.map(Tri).to_vec(),
            Self::COORDS
                .map(|c| vertex(c.to(), 0.0.into()))
                .to_vec(),
        )
    }
}

impl Lathe {
    pub fn new(pts: Vec<Vec2>, sectors: u32) -> Self {
        assert!(sectors >= 3, "sectors must be at least 3, was {sectors}");
        Self { pts, sectors, capped: false }
    }

    pub fn capped(self, capped: bool) -> Self {
        Self { capped, ..self }
    }

    pub fn build(self) -> Mesh<Normal3> {
        let Self { pts, sectors, capped } = self;
        let secs = sectors as usize;

        let mut verts = Vec::with_capacity(pts.len() * (secs + 1) + 2);
        let mut faces = Vec::with_capacity(pts.len() * secs * 2);

        // Create vertices
        for pt in &pts {
            let [r, y] = pt.0;

            for az in (turns(0.0)..=turns(1.0)).vary(sectors) {
                let pt: Vec2 = polar(r, az).into();
                verts.push(vec3(pt.x(), y, pt.y()));
            }
        }
        // Create faces
        for j in 1..pts.len() {
            for i in 1..=secs {
                let a = (j - 1) * (secs + 1) + i - 1;
                let b = (j - 1) * (secs + 1) + i;
                let c = j * (secs + 1) + i - 1;
                let d = j * (secs + 1) + i;
                faces.push([a, b, d]);
                faces.push([a, d, c]);
            }
        }
        if capped && !pts.is_empty() {
            let l = verts.len();
            // Bottom cap
            verts.push(vec3(0.0, pts[0].y(), 0.0));
            for i in 1..=secs {
                faces.push([l, i - 1, i]);
            }
            // Top cap
            verts.push(vec3(0.0, pts[pts.len() - 1].y(), 0.0));
            for i in 1..=secs {
                let a = l + 1;
                let b = (l - 1) - secs + i - 1;
                let c = (l - 1) - secs + i;
                faces.push([a, b, c]);
            }
        }
        Mesh::new(
            faces.into_iter().map(Tri).collect(),
            verts
                .into_iter()
                .map(|p| vertex(p.to(), splat(0.0))) // TODO
                .collect(),
        )
    }
}

impl Sphere {
    pub fn build(self) -> Mesh<Normal3> {
        let Self { sectors, segments, radius } = self;

        let pts = (degs(-90.0)..=degs(90.0))
            .vary(segments)
            .map(|alt| polar(radius, alt).into())
            .collect();

        let mut mesh = Lathe::new(pts, sectors).build();

        for v in &mut mesh.verts {
            let normal = v.pos.normalize();
            *v = vertex(v.pos, normal.to());
        }
        mesh
    }
}

impl Torus {
    pub fn build(self) -> Mesh<Normal3> {
        let pts = (turns(0.0)..=turns(1.0))
            .vary(self.minor_sectors)
            .map(|alt| polar(self.minor_radius, alt))
            .map(|p| vec2(self.major_radius, 0.0) + p.into())
            .collect();

        let mut mesh = Lathe::new(pts, self.major_sectors).build();

        for v in &mut mesh.verts {
            let n = vec3(v.pos.x(), 0.0, v.pos.z()).normalize();
            *v = vertex(v.pos, n);
        }
        mesh
    }
}

impl Cylinder {
    pub fn build(self) -> Mesh<Normal3> {
        let Self { sectors, capped, radius } = self;
        Cone {
            sectors,
            capped,
            base_radius: radius,
            apex_radius: radius,
        }
        .build()
    }
}

impl Cone {
    pub fn build(self) -> Mesh<Normal3> {
        let pts = vec![
            vec2(self.base_radius, -1.0), //
            vec2(self.apex_radius, 1.0),
        ];
        Lathe::new(pts, self.sectors)
            .capped(self.capped)
            .build()
    }
}

impl Capsule {
    pub fn build(self) -> Mesh<Normal3> {
        // Top hemisphere
        let mut top_pts: Vec<_> = (degs(90.0)..=degs(0.0))
            .vary(self.cap_segments)
            .map(|alt| vec2(0.0, 1.0) + polar(self.radius, alt).into())
            .collect();

        // Bottom hemisphere
        let bottom_pts = top_pts.iter().map(|v| vec2(v.x(), -v.y())).rev();

        Lathe::new(
            top_pts
                .iter()
                .copied()
                .chain(bottom_pts)
                .collect(),
            self.sectors,
        )
        .build()
    }
}
